<?php
// $Id$

/**
 * @file
 * Allows Drupal search results to be returned in the OpenSearch RSS format.
 */


final class OpenSearch {
  const API_VERSION = '2.0';

  /**
   * Adds a OpenSearch <link> tag in the current page's <head>.
   *
   * @param $info
   *   A search info object from OpenSearch::getTypeInfo().
   */
  public static function addLink($info) {
    $link = array(
      'href' => url('opensearch/'. $info->type, array('absolute' => TRUE)),
      'title' => OpenSearch::checkPlain($info->type, $info->settings['longname']),
      'rel' => 'search',
      'type' => 'application/opensearchdescription+xml',
    );

    drupal_add_link($link);
  }

  /**
   * Verifies the current API version is included between two values passes as
   * arguments.
   *
   * @param $minimum
   *   The minimum API version required.
   * @param $maximum
   *   The maximum version required. This argument is optional; the current API
   *   will be checked against this value only if it is passed to the function.
   *
   * @return
   *   TRUE, if the current API version is included between the passed values.
   */
  public static function api($minimum, $maximum = NULL) {
    if (version_compare(self::API_VERSION, $minimum, '<')) {
      return FALSE;
    }

    if (isset($maximum) && version_compare(self::API_VERSION, $maximum, '>')) {
      return FALSE;
    }

    return TRUE;
  }

  /**
   * Filters the content of a string used in the OpenSearch descriptor.
   *
   * @param $type
   *   The type of the OpenSearch descriptor.
   * @param $string
   *   The string to be filtered.
   * @param $length
   *   The length of the returned string; if the parameter is not used,
   *   or it is equal to 0, then the string will not be truncated.
   *
   * @return
   *  The filtered string.
   */
  public static function checkPlain($type, $string, $length = 0) {
    if (module_exists('token')) {
      $token_objects = array('global' => NULL);

      if (module_exists('opensearch_token')) {
        $token_objects['search'] = $type;
      }

      $string = token_replace_multiple($string, $token_objects);
    }

    $result = check_plain(
      strip_tags(
        decode_entities(
          preg_replace('/(\r\n?|\n)/', '', $string)
        )
      )
    );

    if ($length) {
      $result = truncate_utf8($result, $length);
    }

    return $result;
  }

  /**
   * Loads the default settings values.
   *
   * @return
   *   An array of default values.
   *
   * @see OpenSearch::loadSettings()
   * @see OpenSearch::saveSettings()
   */
  function defaultSettings() {
    $defaults = array(
      'adult_content' => 0,
      'attribution' => '',
      'contact' => '[site-mail]',
      'description' => '[search-name] search for [site-name].',
      'image_type' => 'theme',
      'image_custom' => '',
      'longname' => '[search-name] search for [site-name]',
      'rss_description' => '[search-name] search results for "[search-keywords]" at [site-name]',
      'rss_title' => '[site-name] [search-name] search: [search-keywords]',
      'shortname' => '[search-name] search',
      'syndication_right' => 'open',
      'tags' => '',
    );

    drupal_alter('opensearch_default_settings', $defaults);

    return $defaults;
  }

  /**
   * Loads the search info object for the search module passed as argument.
   *
   * @param $type
   *   The search module identifier.
   *
   * @return
   *   The search info object containing information about the search module.
   */
  public static function getTypeInfo($type) {
    $vars = new OpenSearchVars();

    if (!module_exists($type)) {
      return FALSE;
    }

    // Do not consider modules that don't return a name.
    $name = module_invoke($type, 'search', 'name');
    if (empty($name)) {
      return FALSE;
    }

    // Check if this search type is enabled.
    $enabled = $vars['opensearch_enabled_types'];
    $bool = (
      empty($enabled) ||
      (isset($enabled) && in_array($type, array_filter($enabled)))
    );
    if ($bool) {
      $info = new stdClass();
      $info->type = $type;
      $info->settings = OpenSearch::loadSettings($type);

      $feeds = $vars['opensearch_enabled_feeds'];

      $info->feed = (
        empty($feeds) ||
        (isset($feeds) && in_array($type, array_filter($feeds)))
      );

      return $info;
    }

    return FALSE;
  }

  /**
   * Checks if the current page is a front-end search page.
   *
   * This should also match any search results pages as well.
   *
   * @return
   *   The module responsible for the current search routine, or an empty
   *   string if the current page is not a search page.
   */
  public static function isSearchPage() {
    $bool = (
      (arg(0) == 'search' || arg(0) == 'opensearch') &&
      ($module = arg(1)) &&
      module_invoke($module, 'search', 'name')
    );

    return $bool ? $module : '';
  }

  /**
   * Loads the module settings.
   *
   * @param $type
   *   The module implementing the search hook to which the options refer to,
   *   or '-default-'.
   *
   * @return
   *   An array containing the module settings.
   */
  public static function loadSettings($type = '-default-') {
    $row = db_fetch_object(
      db_query_range(
        "SELECT settings FROM {opensearch} WHERE type = '%s'", $type, 0, 1
      )
    );
    $settings = array();

    if ($row) {
      $settings = empty($row->settings) ? array() : unserialize($row->settings);

    }

    $settings += self::defaultSettings();

    return $settings;
  }

  /**
   * Saves the module settings.
   *
   * @param $settings
   *   The settings array.
   * @param $type
   *   The module implementing the search hook to which the options refer to, or
   *   '-default-'.
   *
   * @return
   *   An array containing the module settings.
   */
  function saveSettings(array $settings = array(), $type = '-default-') {
    $result = db_fetch_object(
      db_query("SELECT id, type, settings FROM {opensearch} WHERE type = '%s'",
        $type
      )
    );

    if ($result === FALSE) {
      $row = new stdClass();
      $row->type = $type;
    }
    else {
      $row = $result;
    }

    $row->settings = $settings;

    drupal_write_record('opensearch', $row, $result === FALSE ? array() : 'id');
  }

  /**
   * Removes the duplicates from a list of items separated from the separator,
   * preserving the order in which they appear.
   *
   * @param $text
   *   The string containing the list of items concatenated using $separator.
   * @param $separator
   *   The string used to split the string into an array. A space will be
   *   appended to the string before it is used to create the string from the
   *   array of unique items found in the string passed as argument.
   * @param $max_items
   *   The maximum number of items accepted in the returned array; the default
   *   value is -1, which means no limit.
   *
   * @return
   *   A string containing only unique items.
   */
  function uniqueValues($text, $separator = ' ', $max_items = -1) {
    $lc_values = array();
    $unique_values = array();

    if (empty($text)) {
      return '';
    }

    foreach (array_filter(array_map('trim', explode($separator, $text))) as $item) {
      $lowercase = drupal_strtolower($item);

      if (!in_array($lowercase, $lc_values)) {
        $lc_values[] = $lowercase;
        $unique_values[] = $item;
      }
    }

    if ($max_items > 0) {
      $unique_values = array_slice($unique_values, 0, $max_items);
    }

    return implode($separator, $unique_values);
  }
}

/**
 * Allows to access the Drupal variables used by the module.
 */
class OpenSearchVars extends Vars {
  /**
   * Constructs a OpenSearchVars object.
   */
  public function __construct() {
   parent::__construct('opensearch', array(
     'sysVars' => array(
       'menu_rebuild_needed' => FALSE,
     )
   ));
  }

  /**
   * Implements Vars::getDefaults().
   */
  protected function getDefaults() {
    return array(
      'opensearch_enabled_types' => array('value' => NULL),
      'opensearch_enabled_feeds' => array('value' => NULL),
      'opensearch_dismiss_tokens_warning' => array('value' => FALSE),
    );
  }
}

/**
 * Implements hook_init().
 */
function opensearch_init() {
  $headers = drupal_get_headers();

  // Verify the site is not offline, or Drupal is not returning an error page.
  $bool = (
    (
      variable_get('site_offline', 0) &&
      !user_access('administer site configuration')
    ) ||
    preg_match('@HTTP/1\.[01]\x20+403[^a-zA-Z0-9]@', $headers) ||
    preg_match('@HTTP/1\.[01]\x20+404[^a-zA-Z0-9]@', $headers)
  );
  if (!$bool) {
    if ($module = OpenSearch::isSearchPage()) {
      if ($info = OpenSearch::getTypeInfo($module)) {
        // If this is a search-related page, add the OpenSearch link for the current
        // search routine.
        OpenSearch::addLink($info);

        $keywords = trim(search_get_keys());
        if ($keywords) {
          $result_title = OpenSearch::checkPlain($module, $info->settings['rss_title']);

          $query = array();
          foreach ($_GET as $index => $value) {
            if ($index != 'q') {
              $query[$index] = $value;

              if ($index == 'page') {
                $query[$index]++;
              }
            }
          }

          $result_url = url(
            'opensearch/' . $module . '/' . drupal_urlencode($keywords),
            array('absolute' => TRUE, 'query' => $query)
          );
          drupal_add_feed($result_url, $result_title);
        }
      }
    }
    else {
      // On non-search pages, add links for all available OpenSearches.
      foreach (module_implements('search') as $module) {
        if ($info = OpenSearch::getTypeInfo($module)) {
          OpenSearch::addLink($info);
        }
      }
    }
  }
}

/**
 * Implements hook_menu().
 */
function opensearch_menu() {
  $search_content = array('search content');

  $items['opensearch/%opensearch_type'] = array(
    'page callback' => 'opensearch_description',
    'page arguments' => array(1),
    'access arguments' => $search_content,
    'type' => MENU_CALLBACK,
    'file' => 'opensearch.pages.inc',
  );

  $items['opensearch/%opensearch_type/%menu_tail'] = array(
    'page callback' => 'opensearch_view',
    'page arguments' => array(1),
    'access arguments' => $search_content,
    'type' => MENU_CALLBACK,
    'file' => 'opensearch.pages.inc',
  );

  return $items;
}

/**
 * Implements hook_theme().
 */
function opensearch_theme() {
  return array(
    'opensearch_description' => array(
      'arguments' => array('info' => NULL),
      'template' => 'opensearch-description',
    ),
  );
}

/**
 * Menu object load function.
 */
function opensearch_type_load($type) {
  return OpenSearch::getTypeInfo($type);
}

/**
 * Processes variables for opensearch-description.tpl.php.
 */
function template_preprocess_opensearch_description(&$variables) {
  global $base_path;

  $info = $variables['info'];

  $variables['adult_content'] = $info->settings['adult_content'];
  $variables['attribution'] = OpenSearch::checkPlain($info->type, $info->settings['attribution'], 256);
  $variables['contact'] = OpenSearch::checkPlain($info->type, $info->settings['contact']);
  $variables['description'] = OpenSearch::checkPlain($info->type, $info->settings['description'], 1024);
  $variables['longname'] = OpenSearch::checkPlain($info->type, $info->settings['longname'], 48);
  $variables['shortname'] = OpenSearch::checkPlain($info->type, $info->settings['shortname'], 16);
  $variables['syndication_right'] = $info->settings['syndication_right'];
  $variables['tags'] = OpenSearch::uniqueValues(
    OpenSearch::checkPlain($info->type, $info->settings['tags'], 256)
  );
  $variables['url_opensearch'] = str_replace(
    array('%7B', '%7D', '&'),
    array('{', '}', '&amp;'),
    url('opensearch/' . $info->type . '/{searchTerms}', array('absolute' => TRUE))
  );
  $variables['url_search'] = str_replace(
    array('%7B', '%7D', '&'),
    array('{', '}', '&amp;'),
    url('search/' . $info->type . '/{searchTerms}', array('absolute' => TRUE))
  );
  $variables['url_self'] = url('opensearch/' . $info->type, array('absolute' => TRUE));

  $languages = language_list('enabled');
  $variables['languages'] = $languages[1];

  $bool = (
    $info->settings['image_type'] == 'theme' ||
    (
      $info->settings['image_type'] == 'theme' &&
      empty($info->settings['image_custom'])
    )
  );

  if ($bool) {
    init_theme();
    $image_path = theme_get_setting('favicon');
  }
  else {
    $image_path = $info->settings['image_custom'];
  }

  if (isset($image_path)) {
    if (strpos($image_path, $base_path) === 0) {
      $image_path = drupal_substr($image_path, drupal_strlen($base_path));
    }

    if (!empty($image_path)) {
      $attrs = array();
      $image_attributes = @getimagesize($image_path);
      $url_options = array('absolute' => TRUE);

      if (!empty($image_attributes[0])) {
        $attrs['width'] = $image_attributes[0];
      }
      if (!empty($image_attributes[1])) {
        $attrs['height'] = $image_attributes[1];
      }
      if (!empty($image_attributes['mime'])) {
        $attrs['type'] = $image_attributes['mime'];
      }

      $variables['image_attributes'] = drupal_attributes($attrs);
      $variables['image_url'] = url($image_path, array('absolute' => TRUE));
    }
  }
}
